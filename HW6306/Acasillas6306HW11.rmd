---
title: "ACasillas6306HW11"
author: "Arturo Casillas"
date: "November 21, 2017"
output: 
  html_document:
    keep_md: true
---

##1. Warm Up: Brief Financial Data (20%)

###a. Natively in R, you have access to sample data sets of prominent stocks over time. We'll be using EuStockMarkets for this question. Type help(EuStockMarkets) to learn more. From these data, pull specifically the DAX index. For all questions in this assignment, you're welcome to normalize (or don't!) how you see fit, but, if you choose to, please document what you're doing and why for the grader. It's not necessary for the purpose of this assignment.

I look up 'EuStockMarkets' in the help menu and do some very basic data exploration.

```{r, echo=TRUE}

#1.a.
#help(EuStockMarkets)
library(datasets)
library(ggplot2)

str(EuStockMarkets)
dim(EuStockMarkets)
head(EuStockMarkets)

```

###b. These are annual European Stock Data from 1990 onward. Create a rudimentary plot of the data. Make the line blue. Give an informative title. Label the axes accurately. In 1997, an event happened you want to indicate; add a vertical red line to your plot which divides pre-1997 and post-1997 information.

Here's a basic plot with the additional colors and markers requested.

```{r, echo=TRUE}

#1.b.
plot(EuStockMarkets[,1], col='blue', xlab='Year', ylab='Price of DAX', main='DAX vs Time')
abline(v=1997, col='red')

```

###c. Decompose the time series into its components (i.e., trend, seasonality, random). Keep in mind that this is a multiplicative model you want. Create a plot of all decomposed components. As before, make all lines blue and have a vertical divider at the year 1997.

First, the decomposition and a general plot.

```{r, echo=TRUE}
#1.c.
decomp<-decompose(EuStockMarkets[,1])
ls(decomp)

plot(decomp, col='blue', xlab='Year', ylab='Price of DAX')
abline(v=1997, col='red')
```

Now, a closer look at trend.

```{r, echo=TRUE}
#1.c.
plot(decomp$trend, col='blue', xlab='Year', ylab='Price of DAX', main='Trend Component of DAX')
abline(v=1997, col='red')
```

A closer look at the random component

```{r, echo=TRUE}
#1.c.
plot(decomp$random, col='blue', xlab='Year', ylab='Price of DAX', main='Random Component of DAX')
abline(v=1997, col='red')
```

A closer look at seasonal

```{r, echo=TRUE}
#1.c.
plot(decomp$seasonal, col='blue', xlab='Year', ylab='Price of DAX', main='Seasonal Component of DAX')
abline(v=1997, col='red')
```


##2. Temperature Data (40%)

###a. Using the maxtemp dataset granted by loading fpp2, there are maximum annual temperature data in Celsius. For more information, use help(maxtemp). To see what you're looking at, execute the command in 'Examples' in the help document.

From 'help(maxtemp)', I learn to load the 'fpp2' library. For the 'autoplot(maxtemp)' in the example portion of the documentation, I also learn I have to load 'ggplot2'. Furthermore, I load the 'forecast' library here for the rest of no.2.

```{r, echo=TRUE}
#2.a.
#help(maxtemp)
library(forecast)
library(fpp2)
library(ggplot2)
#library(fpp)
autoplot(maxtemp)
#ls('package:fpp2')
```

Note, I did not make any modifications to 'autoplot'. I ran the code exactly as in the 'Examples' portion of the documentation per the instruction.

###b. We are only concerned with information after 1990. Please eliminate unwanted information or subset information we care about.

I will use the 'window' function to subest 'maxtemp' but retain it as a time series.

```{r, echo=TRUE}

#2.b.
#str(maxtemp)
#maxtempsub<-maxtemp[names(maxtemp) >= 1990]
#Retain time series class
maxtempsub<-window(maxtemp, start=1990)
class(maxtempsub)
```

###c. Utilize SES to predict the next five years of maximum temperatures in Melbourne. Plot this information, including the prior information and the forecast. Add the predicted value line across 1990-present as a separate line, preferably blue. So, to review, you should have your fit, the predicted value line overlaying it, and a forecast through 2021, all on one axis. Find the AICc of this fitted model. You will use that information later.

First, define my parameters to use for all modeling later.

```{r, echo=TRUE}
alph=0.5
betab=0.2
```

Now to perform and plot the simple exponential smoothing with alpha of 0.5. The fitted values are in blue and the predicted values are in violet.

```{r, echo=TRUE}
test<-ses(maxtempsub, alpha=alph, initial = 'optimal', h=5)
#test$model
#AICc is in the -$model line
plot(test, type='o', ylab="Max Temperature in Australia", flwd=1, PI = FALSE)
lines(fitted(test), type='o', col='blue2')
lines(test$mean, type='o', col='violetred')
legend('bottomright', lty=1, pch=1, col=c(1, 'blue', 'violetred'), c('original', 'fitted', 'predicted'))
```


###d. Now use a damped Holt's linear trend to also predict out five years. Make sure initial="optimal." As above, create a similar plot to 1C, but use the Holt fit instead.

I do the same as above with alpha of 0.5 and a beta of 0.2. The fitted values are in blue and the predicted values are in violet.

```{r, echo=TRUE}
holttest<-holt(maxtempsub, alpha=alph, beta=betab, initial = 'optimal', h=5, damped=TRUE)

plot(holttest, type='o', ylab="Max Temperature in Australia", flwd=1, PI = FALSE)
lines(fitted(holttest), type='o', col='blue2')
lines(holttest$mean, type='o', col='violetred')
legend('bottomright', lty=1, pch=1, col=c(1, 'blue', 'violetred'), c('original', 'fitted', 'predicted'))
```

###e. Compare the AICc of the ses() and holt() models. Which model is better here?

The corrected Aikake information criteria (AICc) can be found in as parts of the 'ses()' and 'holt()' outputs.

```{r, echo=TRUE}
#2.e.
#Get AICc
#ls(test$model)
test$model$aicc
#ls(holttest$model)
holttest$model$aicc
```

Since the smaller AICc is preferred, the simple exponential smoothing model is preferred to the holt linear trend model.

##3. The Wands Choose the Wizard (40%)

###a. Utilize the dygraphs library. Read in both Unit11TimeSeries_Ollivander and Unit11TimeSeries_Gregorovitch.csv as two different data frames. They do not have headers, so make sure you account for that. This is a time series of Wands sold over years.

Below, I read in the two datasets and the dygraphs library.

```{r, echo=TRUE}
library(dygraphs)
#3.a.
#getwd()
Gregor<-read.csv('C:/Users/acasi/Downloads/Unit11TimeSeries_Gregorovitch.csv', header = FALSE)
Olivander<-read.csv('C:/Users/acasi/Downloads/Unit11TimeSeries_Ollivander.csv', header = FALSE)
```

BTW, I misspelled Ollivander's name.

###b. You don't have your information in the proper format! In both data sets, you'll need to first convert the date-like variable to an actual Date class.

First, I add the names of the data set to make referencing easier.

```{r, echo=TRUE}
#3.b.
names(Gregor)<-c('Date', 'Wands')
names(Olivander)<-c('Date', 'Wands')
```

Now, I use '' to convert the date column into an actual date value.

```{r, echo=TRUE}
Gregor$Date<-as.Date(Gregor$Date, '%d/%m/%Y')
Olivander$Date<-as.Date(Olivander$Date, '%d/%m/%Y')
```

Double check the success of the conversion.

```{r, echo=TRUE}
str(Gregor)
str(Olivander)
```

###c. Use the library xts (and the xts() function in it) to make each data frame an xts object (effectively, a time series). You'll want to order.by the Date variable.

Load the 'xts' library and use 'xts' with an 'order.by' clause on the date to convert the data to time serires.

```{r, echo=TRUE}
#3.c.
library(xts)
#?xts
Gregor.ts <- xts(Gregor$Wands, order.by = Gregor$Date)
Olivander.ts <- xts(Olivander$Wands, order.by = Olivander$Date)
```

Double check the success of the conversion.

```{r, echo=TRUE}
class(Gregor.ts)
class(Olivander.ts)
```

###d. Bind the two xts objects together and create a dygraph from it. Utilize the help() index if you're stuck.
####- Give an effective title and x/y axes.
####- Label each Series (via dySeries) to be the appropriate wand-maker. So, one line should create a label for Ollivander and the other for Gregorovitch.
####- Stack this graph and modify the two lines to be different colors (and not the default ones!) Any colors are fine, but make sure they're visible and that Ollivander is a different color than Gregorovitch.
####- Activate a range selector and make it big enough to view.
####- Use dyShading to illuminate approximately when Voldemort was revived and at-large: between 1995 to 1999.
####- Enable Highlighting on the graph, so mousing over a line bolds it.

First bind, then use 'dygraphs' to plot.

```{r, echo=TRUE}
#3.d.
#bind
Wands<-cbind.xts(Gregor.ts, Olivander.ts)
#plot
dygraph(Wands, ylab = "Wands", xlab = 'Year', main='Wands Sold by Year: 1970-2017') %>% #<--Title & Axes labels
                                    dyAxis("x",drawGrid=FALSE) %>% 
                                    dySeries("..1", label = "Gregorovitch") %>% #<--Series label
                                    dySeries("..2", label = "Ollivander") %>%   #<--Series label
                                    dyOptions(colors=c("red", 'green')) %>%     #<--Series Colors
                                    dyRangeSelector(height=90, strokeColor = "brown") %>%  #<--Range Selector
                                    dyHighlight(hideOnMouseOut=TRUE) %>% #<--Mouse Highlight
                                    dyShading(from = '1995-1-1', to = '1999-1-1', color = "seashell") #<--dyShading
```

By the way, the link to my github repository is here: https://github.com/ArturoCasillas/Acasillas-SMU-MSDS-homework.git